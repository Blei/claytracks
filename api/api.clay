import maybe.*;
import http.*;
import libxml.*;

// apparently the default url doesn't give the most recent tracks when not logged
// in?
var mixesUrl = just(parseUrl("http://8tracks.com/mixes.xml?sort=recent"));
var playtokenUrl = just(parseUrl("http://8tracks.com/sets/new.xml"));

playUrl(playtoken, mixId) {
    return just(parseUrl("http://8tracks.com/sets/" + playtoken
        + "/play.xml?mix_id=" + mixId));
}

record Mix (
    path: String,
    slug: String,
    name: String,
    tagListCach: Vector[String],
    playsCount: Int,
    description: String,
    id: String,
    originalCoverUrl: String,
    sq133CoverUrl: String
);
overload Mix() = Mix(String(), String(), String(), Vector[String](), 0,
    String(), String(), String(), String());

record Track (
    releaseName: String,
    name: String,
    performer: String,
    id: String,
    url: String,
);

// hack for relative urls
private fixCoverUrls(mix) {
    ..for (field in #originalCoverUrl, #sq133CoverUrl) {
        var str = fieldRef(mix, field);
        if (not beginsWith?(str, "http://")) {
            fieldRef(mix, field) = "http://8tracks.com" + str;
        }
    }
}

private parseUser(doc, _userNode, mix) {
    // TODO stuff
}

private parseCoverUrls(doc, _mixNode, mix) {
    var cur = _mixNode^.children;
    while (not null?(cur)) {
        var name = CStringRef(cur^.name);
        if (name == "original") {
            mix.originalCoverUrl = nodeListGetString(doc, cur^.children);
        } else if (name == "sq133") {
            mix.sq133CoverUrl = nodeListGetString(doc, cur^.children);
        }
        cur = cur^.next;
    }
}

private parseMix(doc, cur, mixes) {
    if (xmlStrcmp(cur^.name, xmlString("mix")) != 0) {
        printlnTo(stderr, "Mix is not a mix, it's a ", CStringRef(cur^.name));
        return;
    }

    var mix = Mix();
    var mixNode = cur^.children;
    while (not null?(mixNode)) {
        var name = CStringRef(mixNode^.name);
        if (name == "path") {
            mix.path = nodeListGetString(doc, mixNode^.children);
        } else if (name == "slug") {
            mix.slug = nodeListGetString(doc, mixNode^.children);
        } else if (name == "name") {
            mix.name = nodeListGetString(doc, mixNode^.children);
        } else if (name == "description") {
            mix.description = nodeListGetString(doc, mixNode^.children);
        } else if (name == "id") {
            mix.id = nodeListGetString(doc, mixNode^.children);
        } else if (name == "plays-count") {
            mix.playsCount = Int(nodeListGetString(doc, mixNode^.children));
        } else if (name == "cover-urls") {
            parseCoverUrls(doc, mixNode, mix);
        } else if (name == "user") {
            parseUser(doc, mixNode, mix);
        }

        mixNode = mixNode^.next;
    }

    fixCoverUrls(mix);
    push(mixes, mix);
}

private parseMixes(string) {
    var doc = xmlParseDoc(xmlString(string));
    if (null?(doc)) {
        error("parsing of mixes xml document failed");
    }

    var cur = xmlDocGetRootElement(doc);
    if (null?(doc)) {
        error("Empty mixes document");
    }

    if (xmlStrcmp(cur^.name, xmlString("response")) != 0) {
        xmlFreeDoc(doc);
        error("Incorrect mixes document");
    }

    cur = cur^.children;
    while (not null?(cur)) {
        if (xmlStrcmp(cur^.name, xmlString("mixes")) == 0) {
            cur = cur^.children;
            break;
        }
        cur = cur^.next;
    }

    if (null?(cur)) {
        xmlFreeDoc(doc);
        error("document contains no mixes");
    }

    var mixes = Vector[Mix]();

    while (not null?(cur)) {
        parseMix(doc, cur, mixes);
        cur = cur^.next;
    }

    xmlFreeDoc(doc);
    printlnTo(stderr, "parsing mixes has finished. there are ", size(mixes), " mixes");
    return move(mixes);
}

getMixes() {
    var req = GetRequest();
    var sock = sendRequest(req, mixesUrl);
    var resp = parseResponse(sock, req);
    println(resp.body);
    return move(parseMixes(resp.body));
}

private parsePlaytoken(string) {
    var doc = xmlParseDoc(xmlString(string));
    if (null?(doc)) {
        error("Parsing the playtoken document failed");
    }

    var cur = xmlDocGetRootElement(doc);
    if (null?(cur)) {
        error("Empty playtoken document");
    }

    if (xmlStrcmp(cur^.name, xmlString("response")) != 0) {
        error("Incorrect playtoken xml document");
    }

    cur = cur^.children;

    var playtoken = String();
    
    while (not null?(cur)) {
        if (xmlStrcmp(cur^.name, xmlString("play-token")) == 0) {
            playtoken = nodeListGetString(doc, cur^.children);
            break;
        }

        cur = cur^.next;
    }

    return move(playtoken);
}

getPlaytoken() {
    var req = GetRequest();
    var sock = sendRequest(req, playtokenUrl);
    var resp = parseResponse(sock, req);
    return move(parsePlaytoken(resp.body));
}

private parseTrack(string) {
    var doc = xmlParseDoc(xmlString(string));
    if (null?(doc)) {
        error("Track document parsing failed");
    }

    var cur = xmlDocGetRootElement(doc);
    if (null?(cur)) {
        error("Track document is empty");
    }

    if (xmlStrcmp(cur^.name, xmlString("response")) != 0) {
        error("Track document contains unknown data");
    }

    cur = cur^.children;

    while (not null?(cur)) {
        if (xmlStrcmp(cur^.name, xmlString("set")) == 0) {
            cur = cur^.children;
            break;
        }
        cur = cur^.next;
    }

    while (not null?(cur)) {
        if (xmlStrcmp(cur^.name, xmlString("track")) == 0) {
            cur = cur^.children;
            break;
        }
        cur = cur^.next;
    }

    if (null?(cur)) {
        error("Track contains no set (or the set is empty)");
    }

    var track = Track();

    while (not null?(cur)) {
        var name = String(cur^.name);
        if (name == "release-name") {
            track.releaseName = nodeListGetString(doc, cur^.children);
        } else if (name == "name") {
            track.name = nodeListGetString(doc, cur^.children);
        } else if (name == "performer") {
            track.performer = nodeListGetString(doc, cur^.children);
        } else if (name == "id") {
            track.id = nodeListGetString(doc, cur^.children);
        } else if (name == "url") {
            track.url = nodeListGetString(doc, cur^.children);
        }
        cur = cur^.next;
    }

    return move(track);
}

getTrack(playtoken, mix) {
    var req = GetRequest();
    var url = playUrl(playtoken, mix.id);
    printlnTo(stderr, url.path);
    var sock = sendRequest(req, url);
    var resp = parseResponse(sock, req);
    return move(parseTrack(resp.body));
}
