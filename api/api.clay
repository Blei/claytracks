import maybe.*;
import http.*;
import libxml.*;

// apparently the default url doesn't give the most recent tracks when not logged
// in?
private var mixesUrl = just(parseUrl("http://8tracks.com/mixes.xml?sort=recent"));
private var playtokenUrl = just(parseUrl("http://8tracks.com/sets/new.xml"));

private playUrl(playtoken, mixId) {
    return just(parseUrl("http://8tracks.com/sets/" + playtoken
        + "/play.xml?mix_id=" + mixId));
}

private nextUrl(playtoken, mixId) {
    return just(parseUrl("http://8tracks.com/sets/" + playtoken
        + "/next.xml?mix_id=" + mixId));
}

record Mix (
    path: String,
    slug: String,
    name: String,
    tagListCach: Vector[String],
    playsCount: Int,
    description: String,
    id: String,
    originalCoverUrl: String,
    sq133CoverUrl: String
);
overload Mix() = Mix(String(), String(), String(), Vector[String](), 0,
    String(), String(), String(), String());

record Track (
    releaseName: String,
    name: String,
    performer: String,
    id: String,
    url: String,
);

// hack for relative urls
private fixCoverUrls(mix) {
    ..for (field in #originalCoverUrl, #sq133CoverUrl) {
        var str = fieldRef(mix, field);
        if (not beginsWith?(str, "http://")) {
            fieldRef(mix, field) = "http://8tracks.com" + str;
        }
    }
}

private parseUser(doc, _userNode, mix) {
    // TODO stuff
}

private parseCoverUrls(doc, coverUrlsNode, mix) {
    for (node in XmlNodePtrSequence(coverUrlsNode^.children)) {
        var name = CStringRef(node^.name);
        if (name == "original") {
            mix.originalCoverUrl = nodeListGetString(doc, node^.children);
        } else if (name == "sq133") {
            mix.sq133CoverUrl = nodeListGetString(doc, node^.children);
        }
    }
}

private parseMix(doc, mixNode, mixes) {
    if (xmlStrcmp(mixNode^.name, xmlString("mix")) != 0) {
        printlnTo(stderr, "Mix is not a mix, it's a ", CStringRef(mixNode^.name));
        return;
    }

    var mix = Mix();
    for (node in XmlNodePtrSequence(mixNode^.children)) {
        var name = CStringRef(node^.name);
        if (name == "path") {
            mix.path = nodeListGetString(doc, node^.children);
        } else if (name == "slug") {
            mix.slug = nodeListGetString(doc, node^.children);
        } else if (name == "name") {
            mix.name = nodeListGetString(doc, node^.children);
        } else if (name == "description") {
            mix.description = nodeListGetString(doc, node^.children);
        } else if (name == "id") {
            mix.id = nodeListGetString(doc, node^.children);
        } else if (name == "plays-count") {
            mix.playsCount = Int(nodeListGetString(doc, node^.children));
        } else if (name == "cover-urls") {
            parseCoverUrls(doc, node, mix);
        } else if (name == "user") {
            parseUser(doc, node, mix);
        }
    }

    fixCoverUrls(mix);
    push(mixes, mix);
}

private parseMixes(string) {
    var doc = xmlParseDoc(xmlString(string));
    if (null?(doc)) {
        error("parsing of mixes xml document failed");
    }

    var cur = xmlDocGetRootElement(doc);
    if (null?(doc)) {
        error("Empty mixes document");
    }

    if (xmlStrcmp(cur^.name, xmlString("response")) != 0) {
        xmlFreeDoc(doc);
        error("Incorrect mixes document");
    }

    var mixesNode = null(xmlNode);
    for (node in XmlNodePtrSequence(cur^.children)) {
        if (xmlStrcmp(node^.name, xmlString("mixes")) == 0) {
            mixesNode = node;
            break;
        }
    }

    if (null?(mixesNode)) {
        xmlFreeDoc(doc);
        error("document contains no mixes node");
    }

    var mixes = Vector[Mix]();

    for (node in XmlNodePtrSequence(mixesNode^.children)) {
        parseMix(doc, node, mixes);
    }

    xmlFreeDoc(doc);
    printlnTo(stderr, "parsing mixes has finished. there are ", size(mixes), " mixes");
    return move(mixes);
}

getMixes() {
    var req = GetRequest();
    var sock = sendRequest(req, mixesUrl);
    var resp = parseResponse(sock, req);
    println(resp.body);
    return move(parseMixes(resp.body));
}

private maybeFindIf(seq, pred) {
    for (el in seq) {
        if (pred(el))
            return Maybe(el);
    }
    return nothing(SequenceElementType(Type(seq)));
}

private parsePlaytoken(string) {
    var doc = xmlParseDoc(xmlString(string));
    if (null?(doc)) {
        error("Parsing the playtoken document failed");
    }

    var cur = xmlDocGetRootElement(doc);
    if (null?(cur)) {
        error("Empty playtoken document");
    }

    if (xmlStrcmp(cur^.name, xmlString("response")) != 0) {
        error("Incorrect playtoken xml document");
    }

    var maybePlaytokenNode = maybeFindIf(XmlNodePtrSequence(cur^.children)): node ->
        xmlStrcmp(node^.name, xmlString("play-token")) == 0;

    return maybe(maybePlaytokenNode)
        : node -> nodeListGetString(doc, node^.children)
        :: () -> String();
}

getPlaytoken() {
    var req = GetRequest();
    var sock = sendRequest(req, playtokenUrl);
    var resp = parseResponse(sock, req);
    return move(parsePlaytoken(resp.body));
}

private parseTrack(string) {
    var doc = xmlParseDoc(xmlString(string));
    if (null?(doc)) {
        error("Track document parsing failed");
    }

    var cur = xmlDocGetRootElement(doc);
    if (null?(cur)) {
        error("Track document is empty");
    }

    if (xmlStrcmp(cur^.name, xmlString("response")) != 0) {
        error("Track document contains unknown data");
    }

    var setNode = null(xmlNode);
    for (node in XmlNodePtrSequence(cur^.children)) {
        if (xmlStrcmp(node^.name, xmlString("set")) == 0) {
            setNode = node;
            break;
        }
    }

    var trackNode = null(xmlNode);
    for (node in XmlNodePtrSequence(setNode^.children)) {
        if (xmlStrcmp(node^.name, xmlString("track")) == 0) {
            trackNode = node;
            break;
        }
    }

    if (null?(trackNode)) {
        error("Track contains no set (or the set is empty)");
    }

    var track = Track();

    for (node in XmlNodePtrSequence(trackNode^.children)) {
        var name = String(node^.name);
        if (name == "release-name") {
            track.releaseName = nodeListGetString(doc, node^.children);
        } else if (name == "name") {
            track.name = nodeListGetString(doc, node^.children);
        } else if (name == "performer") {
            track.performer = nodeListGetString(doc, node^.children);
        } else if (name == "id") {
            track.id = nodeListGetString(doc, node^.children);
        } else if (name == "url") {
            track.url = nodeListGetString(doc, node^.children);
        }
    }

    return move(track);
}

getTrack(playtoken, mix) {
    var req = GetRequest();
    var url = playUrl(playtoken, mix.id);
    printlnTo(stderr, url.path);
    var sock = sendRequest(req, url);
    var resp = parseResponse(sock, req);
    return move(parseTrack(resp.body));
}

getNextTrack(playtoken, mix) {
    var req = GetRequest();
    var url = nextUrl(playtoken, mix.id);
    printlnTo(stderr, url.path);
    var sock = sendRequest(req, url);
    var resp = parseResponse(sock, req);
    return move(parseTrack(resp.body));
}
