import api.*;
import http.*;
import maybe.*;
import gstreamer.*;
import glib.*;
import gio.*;
import gobject.*;
import gtk.*;
import gdkpixbuf.*;

private var playbin = Pointer[GstElement](0);
private var playtoken = String();

private var currentTrack = nothing(Track);
private var currentMix = nothing(Mix);

private var currentTrackLabel = null(GtkLabel);
private var nothingPlayingText = cstring("Nothing playing currently");
private var currentlyPlaying? = false;

private var currentClockId = nothing(GstClockID);
private var songReporterRegistered? = false;
private var songReported? = false;

private var playStopButton = null(GtkButton);
private var skipButton = null(GtkButton);

private external watchBus(bus: Pointer[GstBus], message: Pointer[GstMessage], data: gpointer) : gboolean {

    var msgType = message^.type;

    switch (msgType)
    case (GST_MESSAGE_STATE_CHANGED) {
        var oldState = GstState(0);
        var newState = GstState(0);
        var pendingState = GstState(0);
        gst_message_parse_state_changed(message, &oldState, &newState, &pendingState);

        //var newStateName = gst_element_state_get_name(newState);
        //println("Changed state to ", CStringRef(newStateName));

        if (newState == GST_STATE_PLAYING and not songReporterRegistered?) {
            registerSongReporter();
        }
    }
    case (GST_MESSAGE_ERROR) {
        var err = null(GError);
        var debugInfo = null(gchar);
        gst_message_parse_error(message, &err, &debugInfo);
        println("Error: ", String(err^.message));
        println("debug info: ", String(debugInfo));
        g_error_free(err);
        g_free(gpointer(debugInfo));
        currentlyPlaying? = false;

        //gst_element_set_state(playbin, GST_STATE_NULL);
    }
    case (GST_MESSAGE_EOS) {
        var mix = require(currentMix);
        currentTrack = getNextTrack(playtoken, mix);
        playTrack();
    }
    else {
        //println(String(gst_message_type_get_name(msgType)));
    }

    return TRUE;
}

private external destroying(widget: Pointer[GtkWidget], data: gpointer) {
    gtk_main_quit();
}

private external clickedPlay(button: Pointer[GtkButton], data: gpointer) {
    var mix = Pointer[Mix](data);
    currentMix = Maybe(mix^);
    currentTrack = getTrack(playtoken, mix^);
    playTrack();
}

private external clickedPlayPause(button: Pointer[GtkButton], data: gpointer) {
    togglePlaying();
}

private external clickedSkip(button: Pointer[GtkButton], data: gpointer) {
    printlnTo(stderr, "Skip not implemented yet");
}

private external registerPlayingSong(clock: Pointer[GstClock], time: GstClockTime,
        id: GstClockID, data: gpointer) : gboolean {

    println("Reporting track");
    reportTrack(require(currentMix), require(currentTrack));
    songReported? = true;

    gst_clock_id_unref(id);
    currentClockId = nothing(GstClockID);

    // return value ignored, according to docs
    return TRUE;
}

private registerSongReporter() {
    var clock = gst_element_get_clock(playbin);
    if (null?(clock)) {
        printlnTo(stderr, "clock is null");
        return;
    }
    println("Registering Song Reporter");
    var baseTime = gst_element_get_base_time(playbin);
    var clockId = gst_clock_new_single_shot_id(clock, baseTime + GST_SECOND * 30);
    gst_clock_id_wait_async(clockId, GstClockCallback(registerPlayingSong), gpointer(0));

    currentClockId = Maybe(clockId);

    g_object_unref(gpointer(clock));

    songReporterRegistered? = true;
    songReported? = false;
}

private playTrack() {
    maybe(currentTrack) : track -> {
        // Stop left-over song reporter
        if (songReporterRegistered? and not songReported?) {
            gst_clock_id_unschedule(require(currentClockId));
            currentClockId = nothing(GstClockID);
        }

        println("Current track: ", track);
        gtk_label_set_text(currentTrackLabel,
            cstring("'" + track.name + "' by " + track.performer));

        gst_element_set_state(playbin, GST_STATE_NULL);
        g_object_set(gpointer(playbin), cstring("uri"), cstring(track.url), 0);
        gst_element_set_state(playbin, GST_STATE_PLAYING);
        currentlyPlaying? = true;
        songReporterRegistered? = false;
        songReported? = false;
        setControlButtonsSensitive(true);
    } :: () -> {
        println("No current track (end of playlist?)");
        gtk_label_set_text(currentTrackLabel, nothingPlayingText);
        currentlyPlaying? = false;
        setControlButtonsSensitive(false);
    }
}

private togglePlaying() {
    gst_element_set_state(playbin, if (currentlyPlaying?) GST_STATE_PAUSED else GST_STATE_PLAYING);
    currentlyPlaying? = not currentlyPlaying?;
}

private addMixToContainer(mix, container) {
    //println("cover url is ", mix.sq133CoverUrl);
    var url = require(parseUrl(mix.sq133CoverUrl));
    var req = GetRequest();
    var sock = sendRequest(req, url);
    var resp = parseResponse(sock, req);

    var memoryStream = g_memory_input_stream_new_from_data(
        gpointer(cstring(resp.body)),
        Int64(size(resp.body)), GDestroyNotify(0));

    var error = Pointer[GError](0);
    var image = gdk_pixbuf_new_from_stream(memoryStream, null(GCancellable), &error);
    if (not null?(error)) {
        println("error creating pixbuf ", String(error^.message));
        return;
    }

    var hbox = gtk_hbox_new(FALSE, 5);
    gtk_container_add(Pointer[GtkContainer](container), Pointer[GtkWidget](hbox));

    var label = gtk_label_new(cstring(mix.name));
    gtk_box_pack_start(Pointer[GtkBox](hbox), Pointer[GtkWidget](label),
        TRUE, TRUE, UInt32(0));

    var imageWidget = gtk_image_new_from_pixbuf(image);
    gtk_box_pack_end(Pointer[GtkBox](hbox), Pointer[GtkWidget](imageWidget),
        FALSE, FALSE, UInt32(0));

    var button = gtk_button_new_with_label(cstring("Play"));
    gtk_box_pack_end(Pointer[GtkBox](hbox), Pointer[GtkWidget](button),
        FALSE, FALSE, UInt32(0));

    gSignalConnect(button, cstring("clicked"),
        GCallback(clickedPlay), gpointer(&mix));
}

private setControlButtonsSensitive(sensitive?) {
    ..for (button in playStopButton, skipButton) {
        gtk_widget_set_sensitive(Pointer[GtkWidget](button), if (sensitive?) TRUE else FALSE);
    }
}

main(argc, argv) {
    var mixes = getMixes();
    
    playtoken = getPlaytoken();
    println("play token is ", playtoken);

    // let's get some sound going on!
    gst_init(&argc, &argv);

    playbin = gst_element_factory_make(cstring("playbin2"), cstring("play"));

    var bus = gst_element_get_bus(playbin);
    gst_bus_add_watch(bus, GstBusFunc(watchBus), gpointer(0));
    gst_object_unref(gpointer(bus));
    
    // gui ftw
    gtk_init(&argc, &argv);

    var window = gtk_window_new(GTK_WINDOW_TOPLEVEL);
    gtk_window_set_title(Pointer[GtkWindow](window), cstring("Cl8tracks"));
    gtk_window_set_default_size(Pointer[GtkWindow](window), 500, 600);
    gSignalConnect(window, cstring("destroy"),
        GCallback(destroying), gpointer(0));

    var windowBox = gtk_vbox_new(FALSE, 5);
    gtk_container_add(Pointer[GtkContainer](window), Pointer[GtkWidget](windowBox));

    var controlButtonBox = gtk_hbutton_box_new();
    gtk_box_pack_start(Pointer[GtkBox](windowBox), Pointer[GtkWidget](controlButtonBox),
        FALSE, FALSE, 0u);
    gtk_button_box_set_layout(Pointer[GtkButtonBox](controlButtonBox), GTK_BUTTONBOX_CENTER);

    playStopButton = Pointer[GtkButton](gtk_button_new_with_label(cstring("Play/Pause")));
    gtk_container_add(Pointer[GtkContainer](controlButtonBox), Pointer[GtkWidget](playStopButton));
    gSignalConnect(playStopButton, cstring("clicked"),
        GCallback(clickedPlayPause), gpointer(0));

    skipButton = Pointer[GtkButton](gtk_button_new_with_label(cstring("Skip")));
    gtk_container_add(Pointer[GtkContainer](controlButtonBox), Pointer[GtkWidget](skipButton));
    gSignalConnect(skipButton, cstring("clicked"),
        GCallback(clickedSkip), gpointer(0));

    setControlButtonsSensitive(false);

    // whu? that's definitely a label
    currentTrackLabel = Pointer[GtkLabel](gtk_label_new(nothingPlayingText));
    gtk_box_pack_start(Pointer[GtkBox](windowBox), Pointer[GtkWidget](currentTrackLabel),
        FALSE, FALSE, 0u);

    var scrolledWindow = gtk_scrolled_window_new(null(GtkAdjustment), null(GtkAdjustment));
    gtk_scrolled_window_set_policy(Pointer[GtkScrolledWindow](scrolledWindow),
        GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);
    gtk_box_pack_start_defaults(Pointer[GtkBox](windowBox), Pointer[GtkWidget](scrolledWindow));

    var vbox = gtk_vbox_new(FALSE, 5);
    gtk_scrolled_window_add_with_viewport(
        Pointer[GtkScrolledWindow](scrolledWindow), Pointer[GtkWidget](vbox));

    for (mix in mixes) {
        addMixToContainer(mix, vbox);
    }

    gtk_widget_show_all(Pointer[GtkWidget](window));

    gtk_main();

    // cleanup
    gst_element_set_state(playbin, GST_STATE_NULL);
    gst_object_unref(gpointer(playbin));
}
