import api.*;
import http.*;
import maybe.*;
import gstreamer.*;
import glib.*;
import gio.*;
import gobject.*;
import gtk.*;
import gdkpixbuf.*;

private external watchBus(bus: Pointer[GstBus], message: Pointer[GstMessage], data: gpointer) gboolean {

    var msgType = message^.type;
    println(String(gst_message_type_get_name(msgType)));

    if (msgType == GST_MESSAGE_ERROR) {
        var err = null(GError);
        var debugInfo = null(gchar);
        gst_message_parse_error(message, &err, &debugInfo);
        println("Error: ", String(err^.message));
        println("debug info: ", String(debugInfo));
        g_error_free(err);
        g_free(gpointer(debugInfo));

        //gst_element_set_state(playbin, GST_STATE_NULL);
    }

    return TRUE;
}

private external destroying(widget: Pointer[GtkWidget], data: gpointer) {
    gtk_main_quit();
}

private external clickedPlay(button: Pointer[GtkButton], data: gpointer) {
    var mix = Pointer[Mix](data);
    var track = getTrack(playtoken, mix^);
    println(track);
    playTrack(track);
}

private playTrack(track) {
    gst_element_set_state(playbin, GST_STATE_NULL);
    g_object_set(gpointer(playbin), cstring("uri"), cstring(track.url), 0);
    gst_element_set_state(playbin, GST_STATE_PLAYING);
}

private var playbin = Pointer[GstElement](0);
private var playtoken = String();

main() {
    var mixes = getMixes();
    
    playtoken = getPlaytoken();
    println("play token is ", playtoken);

    // let's get some sound going on!
    var argc, argv = ...getArgcArgv();
    gst_init(&argc, &argv);

    playbin = gst_element_factory_make(cstring("playbin2"), cstring("play"));

    var bus = gst_pipeline_get_bus(Pointer[GstPipeline](playbin));
    gst_bus_add_watch(bus, GstBusFunc(watchBus), gpointer(0));
    gst_object_unref(gpointer(bus));
    
    // gui ftw
    gtk_init(&argc, &argv);

    var window = gtk_window_new(GTK_WINDOW_TOPLEVEL);
    gtk_window_set_title(Pointer[GtkWindow](window), cstring("Cl8tracks"));
    gSignalConnect(window, cstring("destroy"),
        GCallback(destroying), gpointer(0));

    var vbox = gtk_vbox_new(TRUE, 5);
    gtk_container_add(Pointer[GtkContainer](window), Pointer[GtkWidget](vbox));

    for (mix in mixes) {
        var hbox = gtk_hbox_new(FALSE, 5);
        gtk_container_add(Pointer[GtkContainer](vbox), Pointer[GtkWidget](hbox));
        var label = gtk_label_new(cstring(mix.name));
        gtk_container_add(Pointer[GtkContainer](hbox), Pointer[GtkWidget](label));
        var button = gtk_button_new_with_label(cstring("Play"));
        gtk_container_add(Pointer[GtkContainer](hbox), Pointer[GtkWidget](button));
        gSignalConnect(button, cstring("clicked"),
            GCallback(clickedPlay), gpointer(&mix));

        println("cover url is ", mix.originalCoverUrl);
        var url = just(parseUrl(mix.originalCoverUrl));
        var req = GetRequest();
        var sock = sendRequest(req, url);
        var resp = parseResponse(sock, req);

        var memoryStream = g_memory_input_stream_new_from_data(
            gpointer(cstring(resp.body)),
            Int64(size(resp.body)), GDestroyNotify(0));

        var error = Pointer[GError](0);
        var image = gdk_pixbuf_new_from_stream(memoryStream,
            null(GCancellable), &error);
        if (not null?(error)) {
            println("error was ", String(error^.message));
            continue;
        }

        var imageWidget = gtk_image_new_from_pixbuf(image);
        gtk_container_add(Pointer[GtkContainer](hbox), Pointer[GtkWidget](imageWidget));
    }

    gtk_widget_show_all(Pointer[GtkWidget](window));

    gtk_main();

    // cleanup
    gst_element_set_state(playbin, GST_STATE_NULL);
    gst_object_unref(gpointer(playbin));
}
